<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id="app">
        <h1>{{msg}}</h1>
        <button @click="addExclamationMark()">Add !</button>
    </div>
    <script src="https://unpkg.com/vue@next">
        // https://book.vue.tw/
        // 開發版本，如發布產品建議改為引入 prod 版本
        // https://uu9924079.medium.com/vue-composition-api-%E7%AD%86%E8%A8%98-%E4%B8%8A-d60eabe3f469
        // https://uu9924079.medium.com/vue-composition-api-%E7%AD%86%E8%A8%98-%E4%B8%8B-4f7e25cdd14
        // Composition API 只是 Vue3 中另一種編寫組件的方法 ，在 Vue3 中仍然可使用 Vue2 編寫組件的方法，其好處如下：
        // 提供更好的 TypeScript 支持
        // 組件太大，需要依功能分類時可使用
        // 需要跨組件使用程式碼
    </script>
    <script>
        // ⭐⭐⭐ 組件範例 ⭐⭐⭐

        const {
            ref
        } = Vue;
        const App = {
            setup() {
                const msg = ref("Hello Vue 3");

                function addExclamationMark() {
                    msg.value += "!";
                }
                return {
                    msg,
                    addExclamationMark,
                };
            },
        };
        Vue.createApp(App).mount("#app");

        // <div id="app">
        //   <app-nav></app-nav>
        //   <app-view>
        //     <app-sidebar></app-sidebar>
        //     <app-content></app-content>
        //   </app-view>
        // </div>

        // ⭐⭐⭐ 局部註冊 ⭐⭐⭐
        // https://v3.cn.vuejs.org/guide/component-registration.html#%E5%B1%80%E9%83%A8%E6%B3%A8%E5%86%8C

        // const ComponentA = {
        // components: {
        //    'component-a': ComponentA,
        //    'component-b': ComponentB
        //  }
        // }
        // const ComponentB = {
        //   components: {
        //     'component-a': ComponentA
        //   }
        //   // ...
        // }

        // ⭐⭐⭐ Prop 向子組件傳遞數據 ⭐⭐⭐ 单向数据流

        // <div id="blog-post-demo" class="demo">
        //   <blog-post title="My journey with Vue"></blog-post>
        //   <blog-post title="Blogging with Vue"></blog-post>
        //   <blog-post title="Why Vue is so fun"></blog-post>
        // </div>

        // <div id="blog-posts-demo">
        //   <blog-post
        //     v-for="post in posts"
        //     :key="post.id"
        //     :title="post.title"
        //   ></blog-post>
        // </div>

        // const app = Vue.createApp({})

        // app.component('blog-post', {
        //   props: ['title'],
        //   template: `<h4>{{ title }}</h4>`
        // })

        // app.mount('#blog-post-demo')

        // ⭐⭐⭐ 監聽子組件自訂事件 ⭐⭐⭐

        // ⭐⭐ 父

        // <blog-post ... @enlarge-text="onEnlargeText"></blog-post>
        // methods: {
        //   onEnlargeText(enlargeAmount) {
        //     this.postFontSize += enlargeAmount
        //   }
        // }

        // ⭐⭐ 子

        // <button @click="$emit('enlarge-text', 0.1)">
        //   Enlarge text
        // </button>

        // app.component('blog-post', {
        //   props: ['title'],
        //   emits: ['enlarge-text']
        // })

        // ⭐⭐⭐ v-model ⭐⭐⭐

        // <input v-model="searchText" />
        // 等於
        // <input :value="searchText" @input="searchText = $event.target.value" />

        // ⭐⭐ Instance Demo

        // ⭐ 第一種方法

        // <custom-input
        //   :model-value="searchText"
        //   @update:model-value="searchText = $event"
        // ></custom-input>

        // app.component('custom-input', {
        //   props: ['modelValue'],
        //   emits: ['update:modelValue'],
        //   template: `
        //     <input
        //       :value="modelValue"
        //       @input="$emit('update:modelValue', $event.target.value)"
        //     >
        //   `
        // })

        // <custom-input v-model="searchText"></custom-input>

        // ⭐ 第二種方法

        // app.component('custom-input', {
        //   props: ['modelValue'],
        //   emits: ['update:modelValue'],
        //   template: `
        //     <input v-model="value">
        //   `,
        //   computed: {
        //     value: {
        //       get() {
        //         return this.modelValue
        //       },
        //       set(value) { this.$emit('update:modelValue', value)
        //       }
        //     }
        //   }
        // })

        // ⭐⭐⭐ slot 插槽模板 ⭐⭐⭐

        // <alert-box>
        //   Something bad happened.
        // </alert-box>

        // app.component('alert-box', {
        //   template: `
        //     <div class="demo-alert-box">
        //       <strong>Error!</strong>
        //       <slot></slot>
        //     </div>
        //   `
        // })

        // ⭐⭐⭐ 動態組件 ⭐⭐⭐

        // <div id="dynamic-component-demo" class="demo">
        //   <button
        //      v-for="tab in tabs"
        //      v-bind:key="tab"
        //      v-bind:class="['tab-button', { active: currentTab === tab }]"
        //      v-on:click="currentTab = tab"
        //    >
        //     {{ tab }}
        //   </button>

        //   <component v-bind:is="currentTabComponent" class="tab"></component>
        // </div>

        // const app = Vue.createApp({
        //   data() {
        //     return {
        //       currentTab: 'Home',
        //       tabs: ['Home', 'Posts', 'Archive']
        //     }
        //   },
        //   computed: {
        //     currentTabComponent() {
        //       return 'tab-' + this.currentTab.toLowerCase()
        //     }
        //   }
        // })

        // app.component('tab-home', {
        //   template: `<div class="demo-tab">Home component</div>`
        // })
        // app.component('tab-posts', {
        //   template: `<div class="demo-tab">Posts component</div>`
        // })
        // app.component('tab-archive', {
        //   template: `<div class="demo-tab">Archive component</div>`
        // })

        // app.mount('#dynamic-component-demo')

        // ⭐⭐⭐ 特例 ⭐⭐⭐

        // v-is 情境 table 內需要出現不是 th tr td 的 tag
        // 要注意属性名不區分大小寫， 驼峰 轉 kebab-cased 原因是 瀏覽器會自動大寫轉小寫再進行辨讀

        // ⭐⭐⭐ 高阶指南 ⭐⭐⭐
        // https://v3.cn.vuejs.org/guide/reactivity.html

        // ⭐ 進階 Provide / Inject => 類似 Angular 的 Service 可能需要這種功能時就要考慮導入 AG

        // const app = Vue.createApp({})

        // app.component('todo-list', {
        //   data() {
        //     return {
        //       todos: ['Feed a cat', 'Buy tickets']
        //     }
        //   },
        //   provide: {
        //      return {
        //        todoLength: this.todos.length
        //      }
        //   },
        //   template: `
        //     <div>
        //       {{ todos.length }}
        //       <!-- 模板的其余部分 -->
        //     </div>
        //   `
        // })

        // app.component('todo-list-statistics', {
        //   inject: ['user'],
        //   created() {
        //     console.log(`Injected property: ${this.user}`) // > 注入 property: John Doe
        //   }
        // })

        //  ⭐⭐ 注入的資料不可變，但可以藉由，注入點用 Computed 包裝，成為連動資料

        // 將 provide 透過 Vue.computed 包裝
        // provide() {
        //     return {
        //         provideMsg: this.msg,
        //         provideMsg2: Vue.computed(() => this.msg)
        //     };
        //  }

        // 'list-item': {
        //     // 由於傳入的是透過 Vue.computed 包裝後的物件，所以要加上 .value
        //     // 有關 .value 的用法在本書最後一章 Composition API 會有更詳細的說明
        //      inject: ['provideMsg', 'provideMsg2'],
        //      template: ` <div>provideMsg: {{ provideMsg }}!</div> <div>provideMsg2: {{ provideMsg2.value }}!</div> `
        //  }

        // ⭐ 声明响应式状态 => 類似 Rxjs 觀察者實例
        // https://v3.cn.vuejs.org/guide/reactivity.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%8D%E5%BA%94%E6%80%A7

        // ⭐ 3.0 Vue Composition API 可取代 Vuex ?

        // 除了 Vuex 之外，Vue 3.0 起新增的 Vue Composition API 也可以用來處理跨元件的資料與程式邏輯共享。
        // 這裏我們將上一個範例用 Composition API 來改寫，首先抽取出共用的邏輯與方法：
        // ⭐⭐ https://jsfiddle.net/kurotanshi/8hsc2yjg/

        // // 共用邏輯
        // const sum = ref(0);
        // const plus = () => sum.value++;
        // const reset = () => sum.value = 0;

        // // 再來，定義父子元件內容，新增的 setup 函式是用來建立與啟動我們的元件，並將模板 <template> 會用到的東西 return 出去：

        // // 父層、根元件
        // const app = createApp({
        //     setup() {
        //         // 將模板用到的 sum, plus 回傳出去
        //         return { sum, plus };
        //     }
        // });
        // // <button-counter>
        // app.component('button-counter',
        //     {
        //         template: `<button @click="plus">You clicked me {{ count }} times.</button>`,
        //         setup(props, { emit }
        //         ) {
        //             const count = ref(0);
        //             // 透過 emit 傳遞自定義事件
        //             const plus = () => {
        //                 count.value++
        //                 emit('add-sum');
        //             };
        //             // 觀察 sum 的變化，若 sum 為 0 代表要 reset count 的內容
        //             watch(sum, v => count.value = v === 0 ? 0 : count.value);
        //             // 將模板用到的 count, plus 回傳出去
        //             return {
        //                 count,
        //                 plus
        //             }
        //         }
        //     });
        // // <button-reset>
        // app.component('button-reset',
        //     {
        //         template: `<button @click="reset">reset</button>`,
        //         setup() {
        //             // 將模板用到的 reset 回傳出去
        //             return { reset }
        //         }
        //     });
    </script>
    <script>
        // Vue composition API 基礎使用 https://book.vue.tw/CH2/2-2-communications.html#vue-composition-api
    </script>
    <script>
        // API 串接 https://book.vue.tw/CH2/2-5-transitions.html
    </script>
</body>

</html>